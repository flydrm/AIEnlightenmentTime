# 解决方案架构师 Prompt 模板

## 角色定位

作为解决方案架构师，我的核心职责是：
- 设计可扩展、高性能、安全的技术架构
- 选择合适的技术栈和架构模式
- 平衡技术理想与业务现实
- 制定技术标准和最佳实践
- 指导团队进行技术决策

## 基础模板

```markdown
# 架构设计请求

## 角色声明
我是[项目名称]的解决方案架构师，负责整体技术架构设计。

## 项目背景
- **业务目标**：[核心业务需求]
- **技术约束**：[现有技术栈/团队能力]
- **质量要求**：[性能/安全/可靠性要求]
- **规模预期**：[用户量/数据量/并发量]
- **时间预算**：[开发周期/预算限制]

## 需要帮助的内容
1. 整体架构设计
2. 技术选型建议
3. 关键技术决策
4. 风险评估与规避
5. 架构演进路线
6. 最佳实践指导

## 期望输出
- 架构设计文档
- 技术选型方案
- 架构图（C4模型）
- 技术风险清单
- 实施路线图
```

## 场景化模板

### 1. 新项目架构设计

```markdown
# Android应用架构设计

## 项目概述
- **应用类型**：[教育/社交/工具/游戏]
- **目标用户**：[用户规模和特征]
- **核心功能**：[3-5个核心功能]
- **特殊要求**：[离线支持/实时同步/AI功能等]

## 技术要求
- **性能目标**
  - 启动时间：< 3秒
  - 响应时间：< 100ms
  - 内存占用：< 150MB
  - 电池消耗：优化

- **可靠性要求**
  - 崩溃率：< 0.1%
  - ANR率：< 0.05%
  - 可用性：99.9%

- **安全要求**
  - 数据加密
  - 安全传输
  - 隐私保护
  - 权限最小化

## 需要设计的架构方案

### 1. 整体架构
- **架构模式选择**
  - Clean Architecture + MVVM
  - 模块化设计
  - 依赖注入
  - 响应式编程

- **分层设计**
  ```
  Presentation Layer (UI/ViewModel)
         ↓
  Domain Layer (UseCase/Repository Interface)
         ↓
  Data Layer (Repository Impl/DataSource)
         ↓
  Infrastructure Layer (Network/Database/Cache)
  ```

### 2. 技术栈选型
- **开发语言**：Kotlin vs Java
- **UI框架**：Jetpack Compose vs XML
- **架构组件**：
  - Navigation Component
  - ViewModel + LiveData/StateFlow
  - Room vs SQLDelight
  - WorkManager vs AlarmManager

- **依赖注入**：Hilt vs Koin vs Dagger
- **网络库**：Retrofit vs Ktor
- **图片加载**：Coil vs Glide
- **异步处理**：Coroutines vs RxJava

### 3. 模块化策略
- 功能模块划分
- 公共组件抽取
- 模块间通信
- 依赖管理

### 4. 数据架构
- 本地存储策略
- 缓存机制设计
- 数据同步方案
- 离线支持实现

### 5. 安全架构
- 认证授权机制
- 数据加密方案
- 通信安全设计
- 代码保护策略

请提供完整的架构设计方案。
```

### 2. 架构演进方案

```markdown
# 架构演进与重构方案

## 现有架构评估
- **当前架构**：[MVC/MVP/其他]
- **技术债务**：[列举主要问题]
- **痛点问题**：
  - 耦合度高
  - 测试困难
  - 扩展性差
  - 性能瓶颈

## 演进目标
- **短期目标**（3个月）
  - 解决紧急问题
  - 建立基础规范
  
- **中期目标**（6个月）
  - 架构分层清晰
  - 模块化初步完成
  
- **长期目标**（12个月）
  - 完整的现代化架构
  - 高度可扩展性

## 演进策略设计

### 1. 渐进式重构路线
#### 第一阶段：基础改造
- 引入Kotlin（如果还是Java）
- 建立代码规范
- 引入依赖注入
- 分离业务逻辑

#### 第二阶段：架构分层
- 实施MVP/MVVM
- 建立Domain层
- Repository模式
- 数据层重构

#### 第三阶段：模块化
- 功能模块拆分
- 组件化通信
- 公共库抽取
- 构建优化

### 2. 关键技术迁移
- **UI层迁移**
  - XML → Jetpack Compose
  - 迁移策略和时间表
  
- **数据层迁移**
  - SQLite → Room
  - SharedPreferences → DataStore
  
- **网络层升级**
  - HttpURLConnection → Retrofit
  - 同步 → 异步/响应式

### 3. 风险控制
- 双轨开发策略
- 功能开关控制
- 灰度发布方案
- 回滚机制

### 4. 度量指标
- 代码质量提升
- 构建时间优化
- 测试覆盖率
- 技术债务减少

请提供详细的架构演进方案。
```

### 3. 性能架构优化

```markdown
# 性能架构优化方案

## 性能现状分析
- **启动性能**：[当前冷启动时间]
- **内存使用**：[平均/峰值内存]
- **UI流畅度**：[FPS/卡顿率]
- **网络性能**：[请求延迟/成功率]
- **电池消耗**：[使用时耗电情况]

## 性能瓶颈
1. [瓶颈1：如启动时初始化过多]
2. [瓶颈2：如图片内存占用大]
3. [瓶颈3：如网络请求串行]

## 优化方案设计

### 1. 启动优化架构
- **异步初始化框架**
  ```kotlin
  interface StartupTask {
      fun priority(): Int
      fun dependencies(): List<Class<out StartupTask>>
      suspend fun execute()
  }
  ```
  
- **延迟加载策略**
  - 按需初始化
  - 懒加载实现
  - 预加载机制

- **启动流程优化**
  - 关键路径识别
  - 并行化改造
  - 无用代码删除

### 2. 内存优化架构
- **图片加载优化**
  - 多级缓存设计
  - 图片压缩策略
  - 内存复用池

- **对象池设计**
  - 频繁创建对象复用
  - 生命周期管理
  - 自动回收机制

- **内存泄漏防护**
  - 生命周期感知组件
  - 弱引用使用
  - 自动检测机制

### 3. UI性能架构
- **渲染优化**
  - 视图复用
  - 异步布局
  - 过度绘制优化

- **列表优化**
  - 分页加载
  - 预加载机制
  - DiffUtil使用

- **动画优化**
  - 硬件加速
  - 属性动画
  - 帧率控制

### 4. 网络架构优化
- **请求优化**
  - 并发控制
  - 请求合并
  - 优先级队列

- **缓存策略**
  - HTTP缓存
  - 本地缓存
  - 增量更新

- **数据压缩**
  - GZIP压缩
  - Protocol Buffers
  - 图片格式优化

### 5. 电量优化架构
- **后台任务管理**
  - WorkManager统一调度
  - 批量处理
  - 电量感知

- **定位优化**
  - 精度动态调整
  - 共享位置信息
  - 地理围栏

- **网络请求优化**
  - 批量同步
  - 推送替代轮询
  - 智能重试

请提供完整的性能优化架构方案。
```

## 进阶模板

### 1. 微服务架构设计

```markdown
# Android端微服务架构设计

## 背景和目标
- **业务复杂度**：[功能模块数量和依赖关系]
- **团队规模**：[开发团队划分]
- **发布频率**：[各模块发布周期]
- **隔离需求**：[故障隔离/版本隔离]

## 微服务架构方案

### 1. 模块化架构
```
app (壳工程)
├── feature-home (首页模块)
├── feature-user (用户模块)
├── feature-content (内容模块)
├── lib-common (公共库)
├── lib-network (网络库)
├── lib-ui (UI组件库)
└── lib-router (路由库)
```

### 2. 模块通信设计
- **路由方案**
  ```kotlin
  // 路由接口定义
  @Route(path = "/user/profile")
  class UserProfileActivity : BaseActivity()
  
  // 路由调用
  Router.navigate("/user/profile") {
      putExtra("userId", 123)
  }
  ```

- **服务暴露**
  ```kotlin
  // 服务接口
  interface IUserService {
      fun getUserInfo(): UserInfo
      fun isLoggedIn(): Boolean
  }
  
  // 服务注册
  @Service
  class UserServiceImpl : IUserService
  ```

### 3. 依赖管理
- Gradle配置管理
- 版本统一管理
- 依赖冲突解决
- 按需加载机制

### 4. 构建优化
- 并行构建
- 增量编译
- 缓存优化
- AAR发布

### 5. 动态化方案
- 插件化框架选型
- 热修复集成
- 动态下发策略
- 版本管理

请设计适合项目的微服务架构方案。
```

### 2. AI功能集成架构

```markdown
# AI功能集成架构设计

## AI功能需求
- **功能列表**
  - 图像识别
  - 语音交互
  - 个性化推荐
  - 智能问答

- **性能要求**
  - 响应时间要求
  - 准确率要求
  - 离线支持需求

## AI架构设计方案

### 1. 整体架构
```
┌─────────────────────────────────┐
│      Presentation Layer         │
├─────────────────────────────────┤
│         AI Service Layer        │
│  ┌─────────┬─────────┬───────┐ │
│  │Vision AI│Voice AI │Text AI│ │
│  └─────────┴─────────┴───────┘ │
├─────────────────────────────────┤
│       AI Engine Layer           │
│  ┌─────────┬─────────┬───────┐ │
│  │TensorFlow│MLKit   │Custom │ │
│  └─────────┴─────────┴───────┘ │
├─────────────────────────────────┤
│     Infrastructure Layer        │
└─────────────────────────────────┘
```

### 2. 端云协同架构
- **端侧AI**
  - 轻量级模型部署
  - 实时推理能力
  - 隐私数据保护
  
- **云端AI**
  - 复杂模型运算
  - 模型更新机制
  - 大数据训练

- **协同策略**
  - 端云任务分配
  - 数据同步机制
  - 降级策略

### 3. AI模型管理
- **模型版本管理**
  - A/B测试框架
  - 灰度发布
  - 回滚机制

- **模型优化**
  - 量化压缩
  - 知识蒸馏
  - 端侧适配

- **模型更新**
  - 增量更新
  - 动态下载
  - 预加载策略

### 4. 数据pipeline
- **数据采集**
  - 埋点设计
  - 隐私合规
  - 数据质量

- **数据处理**
  - 预处理流程
  - 特征工程
  - 实时处理

- **数据安全**
  - 端到端加密
  - 差分隐私
  - 联邦学习

### 5. 性能优化
- 推理加速
- 内存优化
- 功耗控制
- 缓存策略

请提供AI功能集成的架构方案。
```

### 3. 跨平台架构选型

```markdown
# 跨平台架构选型与设计

## 项目需求
- **平台覆盖**：Android + iOS + Web
- **代码复用**：[期望复用比例]
- **性能要求**：[原生性能要求]
- **团队技能**：[技术栈熟悉度]

## 跨平台方案对比

### 1. 技术选型分析
| 方案 | 性能 | 开发效率 | 生态 | 学习成本 | 适用场景 |
|------|------|----------|------|----------|----------|
| KMM | 高 | 中 | 发展中 | 低(Kotlin) | 逻辑复用 |
| Flutter | 中高 | 高 | 成熟 | 中 | 完整应用 |
| React Native | 中 | 高 | 成熟 | 中 | 快速开发 |
| Compose Multiplatform | 高 | 中 | 新兴 | 低(Compose) | UI复用 |

### 2. KMM架构设计
```
shared/
├── commonMain/     # 公共代码
├── androidMain/    # Android特定
├── iosMain/        # iOS特定
└── build.gradle.kts

android/
├── app/           # Android应用
└── build.gradle.kts

ios/
├── iosApp/        # iOS应用
└── Podfile
```

#### 共享模块设计
- **业务逻辑层**
  - UseCase实现
  - 数据模型
  - 业务规则

- **数据层**
  - Repository接口
  - 网络请求
  - 本地存储抽象

- **expect/actual机制**
  ```kotlin
  // Common
  expect class Platform() {
      val platform: String
  }
  
  // Android
  actual class Platform {
      actual val platform = "Android"
  }
  
  // iOS
  actual class Platform {
      actual val platform = "iOS"
  }
  ```

### 3. Flutter架构设计
- **项目结构**
  ```
  lib/
  ├── core/          # 核心功能
  ├── features/      # 功能模块
  ├── shared/        # 共享组件
  └── main.dart
  ```

- **状态管理**
  - Riverpod vs Bloc vs Provider
  - 架构模式选择
  - 数据流设计

- **平台通道**
  - Method Channel
  - Event Channel
  - Platform Views

### 4. 混合开发策略
- 渐进式迁移
- 原生功能保留
- 性能关键模块
- 平台特性处理

### 5. 工程化建设
- CI/CD配置
- 代码规范
- 测试策略
- 发布流程

请推荐最适合的跨平台方案。
```

## 架构决策模板

### 1. ADR (架构决策记录)

```markdown
# ADR-001: 选择[技术/方案]

## 状态
[提议/已接受/已弃用/被XXX取代]

## 背景
[描述需要做决策的背景和问题]

## 决策
我们决定采用[具体方案]

## 原因
- 原因1：[详细说明]
- 原因2：[详细说明]
- 原因3：[详细说明]

## 考虑过的替代方案
### 方案A：[名称]
- 优点：[列举]
- 缺点：[列举]
- 拒绝原因：[说明]

### 方案B：[名称]
- 优点：[列举]
- 缺点：[列举]
- 拒绝原因：[说明]

## 后果
### 积极后果
- [列举]

### 消极后果
- [列举]
- 缓解措施：[说明]

## 参考资料
- [相关文档链接]
- [技术文章]
- [官方文档]
```

### 2. 技术选型评估矩阵

```markdown
# 技术选型评估：[技术类别]

## 评估维度（权重）
- 性能（25%）
- 易用性（20%）
- 生态系统（20%）
- 维护成本（15%）
- 学习曲线（10%）
- 社区活跃度（10%）

## 候选方案评分
| 方案 | 性能 | 易用性 | 生态 | 维护 | 学习 | 社区 | 加权总分 |
|------|------|--------|------|------|------|------|----------|
| A | 9 | 7 | 8 | 6 | 7 | 9 | 7.85 |
| B | 7 | 9 | 9 | 8 | 8 | 8 | 8.15 |
| C | 8 | 6 | 7 | 9 | 6 | 7 | 7.35 |

## 详细分析
[每个方案的详细优缺点分析]

## 建议
基于评估结果，推荐采用[方案X]，因为[核心理由]。
```

### 3. 架构风险评估

```markdown
# 架构风险评估

## 技术风险
| 风险项 | 可能性 | 影响度 | 风险等级 | 缓解措施 |
|--------|--------|--------|----------|----------|
| 新技术学习曲线陡峭 | 高 | 中 | 高 | 培训计划+技术专家支持 |
| 第三方依赖不稳定 | 中 | 高 | 高 | 备选方案+抽象层隔离 |
| 性能不达标 | 低 | 高 | 中 | 性能测试+优化预案 |

## 架构债务
- **现有债务**
  - [债务1]：影响范围和处理计划
  - [债务2]：影响范围和处理计划

- **潜在债务**
  - [预防措施1]
  - [预防措施2]

## 演进风险
- 平滑迁移策略
- 回滚方案准备
- 双轨运行计划
```

## 最佳实践

### 1. 架构原则
- **SOLID原则**：面向对象设计基础
- **DRY原则**：避免重复代码
- **KISS原则**：保持简单直接
- **YAGNI原则**：不过度设计

### 2. 设计模式应用
- **创建型**：单例、工厂、建造者
- **结构型**：适配器、装饰器、代理
- **行为型**：观察者、策略、命令
- **架构型**：MVC、MVP、MVVM、MVI

### 3. 质量属性权衡
- **性能 vs 可维护性**
- **灵活性 vs 简单性**
- **安全性 vs 用户体验**
- **成本 vs 质量**

### 4. 技术债务管理
- **识别**：代码审查、静态分析
- **量化**：债务指数计算
- **优先级**：风险和收益评估
- **偿还**：重构计划执行

## 工具推荐

### 1. 设计工具
- **Draw.io**：架构图绘制
- **PlantUML**：文本化图表
- **C4 Model**：架构可视化
- **Miro/Mural**：协作白板

### 2. 文档工具
- **Markdown**：轻量级文档
- **AsciiDoc**：结构化文档
- **Confluence**：知识管理
- **GitHub Wiki**：项目文档

### 3. 分析工具
- **SonarQube**：代码质量分析
- **Architecture Unit**：架构守护
- **Dependency Check**：依赖分析
- **APK Analyzer**：包体积分析

### 4. 性能工具
- **Android Studio Profiler**：性能分析
- **LeakCanary**：内存泄漏检测
- **Systrace**：系统追踪
- **Firebase Performance**：线上监控

---

**提示**：
- 架构是演进的，不是一成不变的
- 适合的架构比完美的架构更重要
- 始终考虑团队能力和业务约束
- 用数据和事实支撑架构决策